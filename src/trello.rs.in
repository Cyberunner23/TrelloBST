/*
    Copyright (c) 2015, Alex Frappier Lachapelle
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice, this
       list of conditions and the following disclaimer.
    2. Redistributions in binary form must reproduce the above copyright notice,
       this list of conditions and the following disclaimer in the documentation
       and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//TODO: put api calling in a function or macro

use std::error::Error;
use std::io;
use std::io::Read;

use config;

extern crate hyper;
use hyper::Client;
use hyper::client::IntoUrl;
use hyper::client::response::Response;
use hyper::Url;

use serde_json::Value;

extern crate term;


////////////////////////////////////////////////////////////
//                         Macros                         //
////////////////////////////////////////////////////////////

macro_rules! match_to_none {
    ($match_expr:expr) => {
        match $match_expr {
            Ok(_)  => (),
            Err(_) => (),
        }
    }
}


////////////////////////////////////////////////////////////
//                        Structs                         //
////////////////////////////////////////////////////////////

pub struct TrelloBoardInfo {
    pub board_id:      String,
    pub list_id:       String,
    pub build_pass_id: String,
    pub build_fail_id: String,
}


#[derive(Deserialize)]
pub struct BoardNameID {
    pub name: String,
    pub id:   String
}

//response to the /1/boards/[idBoard] api call.
#[derive(Deserialize)]
pub struct MembersMeBoardsResponse {
    pub id:     String,
    pub boards: Vec<BoardNameID>,
}


#[derive(Deserialize)]
pub struct ListInfo {
    pub id:   String,
    pub name: String
}

//response to the /1/boards api call.
#[derive(Deserialize)]
pub struct BoardsResponse {
    pub id:         String,
    pub data:       String,
    pub desc:       String,
    pub lists_list: Vec<ListInfo>
}


////////////////////////////////////////////////////////////
//                         Impls                          //
////////////////////////////////////////////////////////////

impl TrelloBoardInfo {
    pub fn new() -> TrelloBoardInfo {
        TrelloBoardInfo {
            board_id:      "".to_string(),
            list_id:       "".to_string(),
            build_pass_id: "".to_string(),
            build_fail_id: "".to_string(),
        }
    }
}


impl MembersMeBoardsResponse{
    pub fn new() -> MembersMeBoardsResponse{
        MembersMeBoardsResponse{
            id:     "".to_string(),
            boards: Vec::new(),
        }
    }
}


////////////////////////////////////////////////////////////
//                       Functions                        //
////////////////////////////////////////////////////////////

pub fn setup_api(config: &mut config::TrelloBSTAPIConfig) {

    if config.trello_api_key.is_empty() || config.trello_app_token.is_empty() {
        println!("Setting up Trello API Keys...");
    }

    if config.trello_api_key.is_empty() {
        println!("Log into Trello and enter your API key from https://trello.com/app-key : ");
        match io::stdin().read_line(&mut config.trello_api_key) {
            Ok(_)  => {config.trello_api_key = config.trello_api_key.trim_matches('\n').to_string();},
            Err(_) => {panic!("Error while reading the input.");}
        }
    }

    if config.trello_app_token.is_empty(){
        println!("Enter your app token from https://trello.com/1/authorize?response_type=token&key={}&scope=read%2Cwrite&expiration=never&name=TrelloBST : ", config.trello_api_key);
        match io::stdin().read_line(&mut config.trello_app_token) {
            Ok(_)  => {config.trello_app_token = config.trello_app_token.trim_matches('\n').to_string();},
            Err(_) => {panic!("Error while reading the input.");}
        }
    }
}

pub fn acquire_board_list(config: &config::TrelloBSTAPIConfig, board_list: &mut MembersMeBoardsResponse) -> Result<(), &'static str>{

    let     http_client   = Client::new();
    let     api_call      = format!("https://api.trello.com/1/members/me?fields=&boards=open&board_fields=name&key={}&token={}", config.trello_api_key, config.trello_app_token);
    let mut response:       Response;
    let mut response_body = String::new();
    let     api_call_url:   Url;

    match api_call.into_url() {
        Ok(url) => api_call_url = url,
        Err(_)  => return Err("Error while parsing API call url.")
    }

    match http_client.get(api_call_url).send() {
        Ok(res) => response = res,
        Err(_)  => return Err("Error calling the API.")
    }

    match response.read_to_string(&mut response_body){
        Ok(_)  => (),
        Err(_) => return Err("Error converting the API response to a string.")
    }

    if response_body == "invalid key" {
        return Err("The API key is invalid.");
    }

    if response_body == "invalid token" {
        return Err("The app token is invalid.");
    }

    let local_board_list: MembersMeBoardsResponse;
    match serde_json::from_str(&response_body){
        Ok(_board_list) => local_board_list = _board_list,
        Err(_)          => return Err("Error parsing the response.")
    }


    board_list.id     = local_board_list.id;
    board_list.boards = local_board_list.boards;

    Ok(())
}

pub fn create_board_and_list(term: &mut Box<term::StdoutTerminal>, config: &config::TrelloBSTAPIConfig, board_info: &mut TrelloBoardInfo) -> Result<(), &'static str> {

    //Create board
    let mut board_name = String::new();
    loop {
        print!("Please enter a name for the new board: ");
        term.flush();
        match io::stdin().read_line(&mut board_name) {
            Ok(_)  => {
                board_name = board_name.trim_matches('\n').to_string();
                break;
            },
            Err(_) => {
                term.fg(term::color::RED).unwrap();
                writeln!(term, "Error while reading the input.");
                writeln!(term, "Please enter a valid name.");
                term.reset().unwrap();
            }
        }
    }

    let     http_client   = Client::new();
    let mut api_call      = format!("https://trello.com/1/boards?name={}&defaultLists=false&key={}&token={}", board_name, config.trello_api_key, config.trello_app_token);
    let mut response:       Response;
    let mut response_body = String::new();
    let mut api_call_url:   Url;

    match api_call.into_url() {
        Ok(url) => api_call_url = url,
        Err(_)  => return Err("Error while parsing API call url.")
    }

    match http_client.get(api_call_url).send() {
        Ok(res) => response = res,
        Err(_)  => return Err("Error calling the API.")
    }

    match response.read_to_string(&mut response_body){
        Ok(_)  => (),
        Err(_) => return Err("Error converting the API response to a string.")
    }

    if response_body == "invalid key" {
        return Err("Error, the API key is invalid.");
    }

    if response_body == "invalid token" {
        return Err("The app token is invalid.");
    }

    let data: Value;
    match serde_json::from_str(&response_body){
        Ok(_data) => data = _data,
        Err(_)    => return Err("Error parsing the response.")
    }

    board_info.board_id = data.as_object().unwrap().get("id").unwrap().as_string().unwrap().to_string();


    //Create list
    let mut list_name = String::new();
    loop {
        print!("Please enter a name for the list which will contain the build statuses: ");
        term.flush();
        match io::stdin().read_line(&mut list_name) {
            Ok(_)  => {
                list_name = list_name.trim_matches('\n').to_string();
                break;
            },
            Err(_) => {
                term.fg(term::color::RED).unwrap();
                writeln!(term, "Error while reading the input.");
                writeln!(term, "Please enter a valid name.");
                term.reset().unwrap();
            }
        }
    }

    api_call = format!("https://trello.com/1/lists?name={}&idBoard={}&defaultLists=false&key={}&token={}", board_name, board_info.board_id, config.trello_api_key, config.trello_app_token);

    match api_call.into_url() {
        Ok(url) => api_call_url = url,
        Err(_)  => return Err("Error while parsing API call url.")
    }

    match http_client.get(api_call_url).send() {
        Ok(res) => response = res,
        Err(_)  => return Err("Error calling the API.")
    }

    match response.read_to_string(&mut response_body){
        Ok(_)  => (),
        Err(_) => return Err("Error converting the API response to a string.")
    }

    if response_body == "invalid key" {
        return Err("Error, the API key is invalid.");
    }

    if response_body == "invalid token" {
        return Err("The app token is invalid.");
    }

    let data: Value;
    match serde_json::from_str(&response_body){
        Ok(_data) => data = _data,
        Err(_)    => return Err("Error parsing the response.")
    }

    board_info.list_id = data.as_object().unwrap().get("id").unwrap().as_string().unwrap().to_string();

    Ok(())
}

pub fn acquire_board_lists_list(config: &config::TrelloBSTAPIConfig, board_info: &mut TrelloBoardInfo) -> Result<(), &'static str>{

    let     http_client   = Client::new();
    let     api_call      = format!("https://api.trello.com/1/boards/{}?lists=open&list_fields=name&key={}&token={}", config.trello_api_key, config.trello_app_token);
    let mut response:       Response;
    let mut response_body = String::new();
    let     api_call_url:   Url;

    match api_call.into_url() {
        Ok(url) => api_call_url = url,
        Err(_)  => return Err("Error while parsing API call url.")
    }

    match http_client.get(api_call_url).send() {
        Ok(res) => response = res,
        Err(_)  => return Err("Error calling the API.")
    }

    match response.read_to_string(&mut response_body){
        Ok(_)  => (),
        Err(_) => return Err("Error converting the API response to a string.")
    }

    if response_body == "invalid key" {
        return Err("The API key is invalid.");
    }

    if response_body == "invalid token" {
        return Err("The app token is invalid.");
    }

    let local_board_list: MembersMeBoardsResponse;
    match serde_json::from_str(&response_body){
        Ok(_board_list) => local_board_list = _board_list,
        Err(_)          => return Err("Error parsing the response.")
    }


    board_list.id     = local_board_list.id;
    board_list.boards = local_board_list.boards;

    Ok(())

    //TODO: Finish this.
}

pub fn select_lists(board_id: String, ) {

}

























