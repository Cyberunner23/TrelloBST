/*
    Copyright (c) 2015, Alex Frappier Lachapelle
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice, this
       list of conditions and the following disclaimer.
    2. Redistributions in binary form must reproduce the above copyright notice,
       this list of conditions and the following disclaimer in the documentation
       and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//TODO: put api calling in a function or macro

use std::error::Error;
use std::io;
use std::io::Read;

use config;

extern crate hyper;
use hyper::Client;
use hyper::client::IntoUrl;
use hyper::client::response::Response;
use hyper::Url;

use serde_json::Value;

extern crate term;

mod utils;


////////////////////////////////////////////////////////////
//                         Macros                         //
////////////////////////////////////////////////////////////

include!("utils_macros.rs");


////////////////////////////////////////////////////////////
//                        Structs                         //
////////////////////////////////////////////////////////////

pub struct TrelloBoardInfo {
    pub board_id:      String,
    pub list_id:       String,
    pub build_pass_id: String,
    pub build_fail_id: String,
}


#[derive(Deserialize)]
pub struct BoardNameID {
    pub name: String,
    pub id:   String
}

//response to the /1/boards/[idBoard] api call.
#[derive(Deserialize)]
pub struct MembersMeBoardsResponse {
    pub id:     String,
    pub boards: Vec<BoardNameID>,
}


#[derive(Deserialize)]
pub struct ListInfo {
    pub id:   String,
    pub name: String
}

//response to the /1/boards api call.
#[derive(Deserialize)]
pub struct BoardsResponse {
    pub id:    String,
    pub name:  String,
    pub desc:  String,
    pub lists: Vec<ListInfo>
}


////////////////////////////////////////////////////////////
//                         Impls                          //
////////////////////////////////////////////////////////////

impl TrelloBoardInfo {
    pub fn new() -> TrelloBoardInfo {
        TrelloBoardInfo {
            board_id:      "".to_string(),
            list_id:       "".to_string(),
            build_pass_id: "".to_string(),
            build_fail_id: "".to_string(),
        }
    }
}


impl MembersMeBoardsResponse{
    pub fn new() -> MembersMeBoardsResponse{
        MembersMeBoardsResponse{
            id:     "".to_string(),
            boards: Vec::new(),
        }
    }
}


impl BoardsResponse {
    pub fn new() -> BoardsResponse{
        BoardsResponse {
            id:    "".to_string(),
            name:  "".to_string(),
            desc:  "".to_string(),
            lists: Vec::new(),
        }
    }
}


////////////////////////////////////////////////////////////
//                       Functions                        //
////////////////////////////////////////////////////////////

pub fn setup_api(term: &mut Box<term::StdoutTerminal>, config: &mut config::TrelloBSTAPIConfig) {

    if config.trello_api_key.is_empty() || config.trello_app_token.is_empty() {
        println!("Setting up Trello API Keys...");
    }

    if config.trello_api_key.is_empty() {
        get_input_string!(term, &mut config.trello_api_key, "Log into Trello and enter your API key from https://trello.com/app-key : ");
    }

    if config.trello_app_token.is_empty(){
        print!("Enter your app token from https://trello.com/1/authorize?response_type=token&key={}&scope=read%2Cwrite&expiration=never&name=TrelloBST : ", config.trello_api_key);
        match_to_none!(term.flush());
        get_input_string!(term, &mut config.trello_app_token, "");
    }
}

pub fn acquire_board_list(config: &config::TrelloBSTAPIConfig, board_list: &mut MembersMeBoardsResponse) -> Result<(), &'static str>{

    let     api_call      = format!("https://api.trello.com/1/members/me?fields=&boards=open&board_fields=name&key={}&token={}", config.trello_api_key, config.trello_app_token);
    let mut response_body = String::new();

    match utils::rest_api_call_get(&api_call) {
        Ok(_response_body) => response_body = _response_body,
        Err(err)           => return Err(err)
    }

    let local_board_list: MembersMeBoardsResponse;
    match serde_json::from_str(&response_body){
        Ok(_board_list) => local_board_list = _board_list,
        Err(_)          => return Err("Error parsing the response.")
    }

    board_list.id     = local_board_list.id;
    board_list.boards = local_board_list.boards;

    Ok(())
}

pub fn create_board_and_list(term: &mut Box<term::StdoutTerminal>, config: &config::TrelloBSTAPIConfig, board_info: &mut TrelloBoardInfo) -> Result<(), &'static str> {

    //Create board
    let mut board_name             = String::new();
    let mut is_input_success: bool = false;
    loop {
        get_input_string!(term, &mut board_name, &mut is_input_success, "Please enter a name for the new board: ");
        if is_input_success {break;}
    }

    let mut api_call      = format!("https://trello.com/1/boards?name={}&defaultLists=false&key={}&token={}", board_name, config.trello_api_key, config.trello_app_token);
    let mut response_body = String::new();

    match utils::rest_api_call_post(&api_call) {
        Ok(_response_body) => response_body = _response_body,
        Err(err)           => return Err(err)
    }

    let data: Value;
    match serde_json::from_str(&response_body){
        Ok(_data) => data = _data,
        Err(_)    => return Err("Error parsing the response.")
    }

    //TODO: Better error reporting
    board_info.board_id = data.as_object().unwrap().get("id").unwrap().as_string().unwrap().to_string();

    create_list(term, &config, board_info);

    board_info.list_id = data.as_object().unwrap().get("id").unwrap().as_string().unwrap().to_string();

    Ok(())
}

pub fn acquire_board_lists_list(config: &config::TrelloBSTAPIConfig, board_info: &TrelloBoardInfo, board_lists_list: &mut BoardsResponse) -> Result<(), &'static str>{

    let     api_call      = format!("https://api.trello.com/1/boards/{}?lists=open&list_fields=name&fields=name,desc&key={}&token={}",board_info.board_id, config.trello_api_key, config.trello_app_token);
    let mut response_body = String::new();

    match utils::rest_api_call_get(&api_call) {
        Ok(_response_body) => response_body = _response_body,
        Err(err)           => return Err(err)
    }

    let local_board_lists_list: BoardsResponse;
    match serde_json::from_str(&response_body){
        Ok(_board_lists_list) => local_board_lists_list = _board_lists_list,
        Err(_)                => return Err("Error parsing the response.",)
    }

    board_lists_list.id    = local_board_lists_list.id;
    board_lists_list.name  = local_board_lists_list.name;
    board_lists_list.desc  = local_board_lists_list.desc;
    board_lists_list.lists = local_board_lists_list.lists;

    Ok(())

}

pub fn create_list(term: &mut Box<term::StdoutTerminal>, config: &config::TrelloBSTAPIConfig, board_info: &mut TrelloBoardInfo) -> Result<(), &'static str> {

    let mut list_name        = String::new();
    let mut is_input_success = false;
    loop {
        get_input_string!(term, &mut list_name, &mut is_input_success, "Please enter a name for the list which will contain the build statuses: ");
        if is_input_success {break;}
    }

    let api_call          = format!("https://trello.com/1/lists?name={}&idBoard={}&defaultLists=false&key={}&token={}", list_name, board_info.board_id, config.trello_api_key, config.trello_app_token);
    let mut response_body = String::new();

    match utils::rest_api_call_post(&api_call) {
        Ok(_response_body) => response_body = _response_body,
        Err(err)           => return Err(err)
    }

    let data: Value;
    match serde_json::from_str(&response_body){
        Ok(_data) => data = _data,
        Err(_)    => return Err("Error parsing the response.")
    }

    //TODO: Better error reporting
    board_info.list_id = data.as_object().unwrap().get("id").unwrap().as_string().unwrap().to_string();

    Ok(())
}

pub fn create_pass_fail_labels(config: &config::TrelloBSTAPIConfig, board_info: &mut TrelloBoardInfo) -> Result<(), &'static str> {

    //TODO?: Check if labels already exist for the board.

    let mut api_call = format!("https://trello.com/1/boards/{}/labels?name=BUILD%20PASS&color=green&key={}&token={}", board_info.board_id, config.trello_api_key, config.trello_app_token);
    let mut response_body = String::new();

    match utils::rest_api_call_post(&api_call) {
        Ok(_response_body) => response_body = _response_body,
        Err(err)           => return Err(err)
    }

    let data: Value;
    match serde_json::from_str(&response_body){
        Ok(_data) => data = _data,
        Err(_)    => return Err("Error parsing the response.")
    }

    //TODO: Better error reporting
    board_info.build_pass_id = data.as_object().unwrap().get("id").unwrap().as_string().unwrap().to_string();


    //create build fail label
    response_body.clear();
    api_call.clear();
    api_call = format!("https://trello.com/1/boards/{}/labels?name=BUILD%20FAIL&color=red&key={}&token={}", board_info.board_id, config.trello_api_key, config.trello_app_token);

    match utils::rest_api_call_post(&api_call) {
        Ok(_response_body) => response_body = _response_body,
        Err(err)           => return Err(err)
    }

    let data: Value;
    match serde_json::from_str(&response_body){
        Ok(_data) => data = _data,
        Err(_)    => return Err("Error parsing the response.")
    }

    //TODO: Better error reporting
    board_info.build_fail_id = data.as_object().unwrap().get("id").unwrap().as_string().unwrap().to_string();

    Ok(())
}

























