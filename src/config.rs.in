/*
    Copyright (c) 2015, Alex Frappier Lachapelle
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice, this
       list of conditions and the following disclaimer.
    2. Redistributions in binary form must reproduce the above copyright notice,
       this list of conditions and the following disclaimer in the documentation
       and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


use std::env;
use std::fs::{File, Metadata, OpenOptions};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};

extern crate term;

mod utils;


////////////////////////////////////////////////////////////
//                         Macros                         //
////////////////////////////////////////////////////////////

include!("utils_macros.rs");


////////////////////////////////////////////////////////////
//                        Structs                         //
////////////////////////////////////////////////////////////

pub struct TrelloBSTConfigPath {
    pub config_path: PathBuf
}


#[derive(Serialize, Deserialize)]
pub struct TrelloBSTAPIConfig {
    pub trello_api_key:      String,
    pub trello_app_token:    String,
    pub travis_access_token: String,
    pub appveyor_api_token:  String,
}


////////////////////////////////////////////////////////////
//                         Impls                          //
////////////////////////////////////////////////////////////

impl TrelloBSTConfigPath {

    pub fn new() -> TrelloBSTConfigPath {
        TrelloBSTConfigPath {
            config_path: PathBuf::new(),
        }
    }

    pub fn get_config_dir(term: &mut Box<term::StdoutTerminal>, is_using_config_file: &mut bool, is_using_custom_config: &bool, path_str: &str) -> Result<TrelloBSTConfigPath, ()>{
        if *is_using_custom_config {
            let path     = Path::new(path_str);
            let status   = utils::StatusPrint::from_string(term, format!("Looking for the configuration file: {}", path_str.to_string()));
            match TrelloBSTConfigPath::try_custom_config_path(path) {
                Ok(config_path) => {
                    status.success(term);
                    return Ok(config_path);
                },
                Err(err)        => {
                    *is_using_config_file = false;
                    status.error(term);
                    writeln_red!(term, "An error occurred: {}", err);
                    writeln_red!(term, "Configuration file won't be used...");
                    return Err(());
                },
            };
        } else {
            let status = utils::StatusPrint::from_str(term, "Looking for the configuration file in default location...");
            match TrelloBSTConfigPath::try_default_config_path() {
                Ok(config_path) => {
                    status.success(term);
                    return Ok(config_path);
                },
                Err(err)        => {
                    *is_using_config_file = false;
                    status.error(term);
                    writeln_red!(term, "An error occurred: {}", err);
                    writeln_red!(term, "Configuration file won't be used...");
                    return Err(());
                },
            };
        }
    }

    pub fn try_default_config_path() -> Result<TrelloBSTConfigPath, &'static str> {

        //Check for an existing config file
        let mut trellobst_config_path = TrelloBSTConfigPath::new();
        let mut _home_dir_found:        bool;

        match env::home_dir() {
            Some(home_dir) => {
                trellobst_config_path.config_path = home_dir;
                _home_dir_found                   = true;
            },
            None           => {
                _home_dir_found = false;
            }
        };

        if _home_dir_found {
            trellobst_config_path.config_path.push(".TrelloBST.cfg");
            //Try to open the file with r/w permissions
            match OpenOptions::new().read(true).write(true).create(true).open(trellobst_config_path.config_path.as_path()) {
                Ok(_)  => {
                    Ok(trellobst_config_path)
                }
                Err(_) => {
                    Err("Cannot open/create configuration file at default location.")
                }
            }
        } else {
            Err("Cannot open/create configuration file at default location.")
        }
    }

    pub fn try_custom_config_path(config_path: &Path) -> Result<TrelloBSTConfigPath, &'static str>{
        //Try to open the file with r/w permissions
        match OpenOptions::new().read(true).write(true).create(true).open(config_path) {
            Ok(_)  => {
                Ok(TrelloBSTConfigPath{config_path: PathBuf::from(config_path)})
            }
            Err(_) => {
                Err("Cannot open/create configuration file at custom location.")
            }
        }
    }

}


impl TrelloBSTAPIConfig {

    pub fn new() -> TrelloBSTAPIConfig {
        TrelloBSTAPIConfig {
            trello_api_key:      "".to_string(),
            trello_app_token:    "".to_string(),
            travis_access_token: "".to_string(),
            appveyor_api_token:  "".to_string(),
        }
    }

    pub fn from_file(config_path: &TrelloBSTConfigPath) -> Result<TrelloBSTAPIConfig, &'static str>{

        let mut file: File;
        match File::open(config_path.config_path.as_path()) {
            Ok(_file) => {
                file = _file;
            }
            Err(_)    =>{
                return Err("Cannot open config file for parsing, configuration file won't be used...");
            }
        }

        let metadata: Metadata;
        match file.metadata() {
            Ok(_metadata)  => {
                metadata = _metadata;
            }
            Err(_)         => {
                return Err("Cannot gather metadata of the configuration file, configuration file won't be used...")
            }
        }

        let api_config         = TrelloBSTAPIConfig::new();
        let file_length: usize = metadata.len() as usize;
        if file_length == 0 {
            return Ok(api_config)
        } else {
            let mut data: String = String::with_capacity(file_length +1);
            match file.read_to_string(&mut data) {
                Ok(_)  => {
                    //TODO: better error checking
                    return Ok(serde_json::from_str(&data[..]).unwrap())
                },
                Err(_) => {
                    return Err("Error while reading the configuration file, configuration file won't be used...")
                }
            }
        }
    }

    pub fn save_config(config_path: &TrelloBSTConfigPath, config: &TrelloBSTAPIConfig) -> Result<(), &'static str> {
        match File::create(config_path.config_path.as_path()) {
            Ok(file)  => {
                //TODO: better error reporting
                let     config_json = serde_json::to_string(&config).unwrap();
                let mut config_file = file;
                match config_file.write(&config_json.into_bytes()[..]) {
                    Ok(_)  => Ok(()),
                    Err(_) => Err("Error while saving the configuration file...")
                }
            }
            Err(_)    => {
                Err("Cannot open configuration for saving...")
            }
        }
    }
}



